\chapter{Adjustments}
GTK有各种部件，可以在视觉上由用户使用鼠标或键盘，调整诸如范围
在范围小部件“部分中描述的窗口小部件，。也有一些小工具，显示一些调整的部分
一个更大的区域的数据，如文本小部件和视口小部件。

显然，一个应用程序需要能够进行反应的变化用户使得在范围构件。做到这一点
的方法之一将各部件发出自己的类型的信号时，其调整的变化，并通过新的价值
信号处理程序，或者需要它，看看里面的小部件的数据结构，以确定它的价值。
但是，您可能要连接在一起的几个小部件的调整，使调整一个调整。最
明显的例子是将一个滚动条的平移视口或滚动文字区。如果每个小部件都有其
自己的方式设置或获取调整值，那么程序员可能需要编写自己的信号处理程序
翻译的一个小部件的信号和输出之间的“输入”的调整设置方法。

GTK使用Adjustment object解决这个问题，，这是不是一个部件，
但窗口小部件的方式来存储和在一个抽象的，灵活的形式，通过
调整信息。调整最明显的用途是存储
配置参数和值范围构件，比如滚动条和规模控制。然而，由于
Adjustment是从Object派生的，他们有一些特殊的超出正常数据结构的权力。
最重要的是，他们可以发出信号，就像小部件，并可以使用这些信号，
不仅是为了让你的程序反应在可调节的窗口小部件的用户输入，但也传播的
调节值之间透明可调小部件。
您将看到如何调整适合当你看到其他小工具,把它们:进度条,视口,滚动Windows和其它。	
\section{Creating an Adjustment}
很多使用的小部件，这样做自动的调整对象，但某些情况下，将在后面的示例所示
在那里你可能需要自己创建一个。您可以创建一个调整使用：
adjustment = gtk.Adjustment(value=0, lower=0, upper=0, step_incr=0,
	page_incr=0, page_size=0)
value参数的初始值，你想给的adjustment，通常对应可调节的窗口小部件到最上面的
或最左边的位置。参数指定的最低值调整可以持有。 step_incr参数指定的
“小”的两个增量的用户可以改变值，而page_incr是“较大”之一。 PAGE_SIZE参数
通常以某种方式对应的摇摄小部件的可见区域。上的参数被用来代表底部大部分或
最右边的坐标在一个平移widget的孩子。因此，它并不总是的最大数目值可以采用,
因为所以page_size这些小部件通常是非零。
\section{Using Adjustment the Easy Way}
可调整的小部件可以大致分为那些使用并需要特定的单位为这些值，并那些把他们当作
任意数字。本组将任意数量的值，包括范围窗口小部件（滚动条和规模，进度条窗口
小部件，旋转按钮部件）。这些小部件是所有的部件
这是典型的“调整”，直接由用户用鼠标或键盘。他们将治疗的下限和上限
值调整为一个范围内，用户可以操纵的调整的值。默认情况下，他们会
只修改值的调整

另一组则包含文本构件，视角构件，的化合物列表窗口小部件，并滚动窗口
小部件。所有这些部件都使用其调整的像素值。这也是所有小部件，通常
“调整”间接使用滚动条。虽然所有的小部件，使用调整可以创建自己的调整
或使用您提供的，您通常希望让这个特定类别的部件，创建自己的调整。
通常情况下，他们最终将覆盖所有的值，除了本身的价值的任何调整，你给他们，但
的结果是，在一般情况下，不确定的（意思是，你会读的源代码，找出，并可能会有所不同
从部件到部件）。
现在，你可能会想，既然文本组件和视口设置的价值，他们的一切，除了坚持
调整，而滚动条将只摸调整的价值，如果你共享一个调整对象之间的
操作滚动条滚动条和一个文本组件，将自动地调整文字的小工具吗？当然会！
就像这样：	
# create its own adjustments
viewport = gtk.Viewport()
# uses the newly-created adjustment for the scrollbar as well
vscrollbar = gtk.VScrollbar(viewport.get_vadjustment())
\section{Adjustment Internals}
好吧，你说，这是很好的，但如果我要创建我自己的处理程序，以响应用户调整范围构件
或旋转按钮，我如何才能在这些处理程序的调整的价值吗？为了回答这些问题，
多了，让我们开始考虑看看在一个gtk.Adjustment本身的属性：	
lower
upper
value
step_increment
page_increment
page_size
由于的一个gtk.Adjustment实例ADJ，每个属性检索或设置，由adj.lower，adj.value，
等等
因为，当你设置值的调整，你一般都希望的变化所反映的每一个部件，
使用这种调整中，PyGTK的提供了一个方法来做到这一点：	
adjustment.set_value(value)
正如前面提到的，调整是Object的子类就像所有的各种部件，因此它是
能够发出信号。当然，这是为什么更新自动的，当你分享的调整对象
之间的滚动条和其他可调整构件，所有的可调部件连接信号处理程序，其调整的
value_changed的信号，你的程序。下面是这个信号的回调定义：	
def value_changed(adjustment):
使用调整对象的各种部件，将发出此信号时，他们改变的调整
它的值。这种情况发生在当用户输入引起的滑块上移动的范围内小部件，以及当程序
明确地改变与set_value（）方法的值。因此，举例来说，如果你有一个规模小部件，而你
要改变旋转的图片时，其值发生变化，您将创建一个这样的回调：
def cb_rotate_picture(adj, picture):
set_picture_rotation (picture, adj.value)
...
并把它连接到这样的规模小部件的调整：
adj.connect("value_changed", cb_rotate_picture, picture)

一个部件时，重新配置它的调整，例如，当用户增加了更多的的上部或下部的字段
文本到文本构件？在这种情况下，它会发出改变的信号，它看起来像这样：	
def changed(adjustment):
范围构件，通常是连接到该信号处理程序，这会改变他们的外观，以反映变化 - 
例如，一个滚动条中的滑块的大小将增长或收缩成反比地之间的差
其调整值的下限和上限。
你可能不会需要一个处理程序附加到这个信号，除非你正在编写一个新的类型的范围构件。
但是，如果你在调整直接改变任何的值，你应该发出这个信号，它重新配置
任何部件都在使用它，就像这样：
adjustment.emit("changed")


